// Copyright (c) 2018 The MATRIX Authors
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php
// Code generated by github.com/fjl/gencodec. DO NOT EDIT.

package types

import (
	"encoding/json"
	"math/big"

	"errors"
	"github.com/MatrixAINetwork/go-matrix/common"
	"github.com/MatrixAINetwork/go-matrix/common/hexutil"
	"github.com/MatrixAINetwork/go-matrix/params/manversion"
)

var _ = (*headerMarshaling)(nil)

func (h Header) MarshalJSON() ([]byte, error) {
	if manversion.VersionCmp(string(h.Version), manversion.VersionAIMine) >= 0 {
		type Header struct {
			ParentHash common.Hash       `json:"parentHash"       gencodec:"required"`
			UncleHash  common.Hash       `json:"sha3Uncles"       gencodec:"required"`
			Coinbase   common.Address    `json:"miner"            gencodec:"required"`
			Roots      []common.CoinRoot `json:"stateRoot"        gencodec:"required"`
			Sharding   []common.Coinbyte `json:"sharding"         gencodec:"required"`
			Difficulty *hexutil.Big      `json:"difficulty"       gencodec:"required"`
			Number     *hexutil.Big      `json:"number"           gencodec:"required"`
			GasLimit   hexutil.Uint64    `json:"gasLimit"         gencodec:"required"`
			GasUsed    hexutil.Uint64    `json:"gasUsed"          gencodec:"required"`
			Time       *hexutil.Big      `json:"timestamp"        gencodec:"required"`
			Extra      hexutil.Bytes     `json:"extraData"        gencodec:"required"`
			MixDigest  common.Hash       `json:"mixHash"          gencodec:"required"`
			Nonce      BlockNonce        `json:"nonce"            gencodec:"required"`

			Leader            common.Address     `json:"leader"            gencodec:"required"`
			Elect             []common.Elect     `json:"elect"        gencodec:"required"`
			NetTopology       common.NetTopology `json:"nettopology"        gencodec:"required"`
			Signatures        []common.Signature `json:"signatures"        gencodec:"required"`
			VersionSignatures []common.Signature `json:"versionSignatures"              gencodec:"required"`
			Version           string             `json:" version "              gencodec:"required"`
			VrfValue          hexutil.Bytes      `json:"vrfValue"              gencodec:"required"`
			AIHash            common.Hash        `json:"aiHash"    		gencodec:"required"`

			Hash common.Hash `json:"hash"`
		}
		var enc Header
		enc.ParentHash = h.ParentHash
		enc.UncleHash = h.UncleHash
		enc.Coinbase = h.Coinbase
		enc.Roots = h.Roots
		enc.Sharding = h.Sharding
		enc.Difficulty = (*hexutil.Big)(h.Difficulty)
		enc.Number = (*hexutil.Big)(h.Number)
		enc.GasLimit = hexutil.Uint64(h.GasLimit)
		enc.GasUsed = hexutil.Uint64(h.GasUsed)
		enc.Time = (*hexutil.Big)(h.Time)
		enc.Extra = h.Extra
		enc.MixDigest = h.MixDigest
		enc.Nonce = h.Nonce
		enc.Leader = h.Leader
		enc.Elect = h.Elect
		enc.NetTopology = h.NetTopology
		enc.Signatures = h.Signatures
		enc.VersionSignatures = h.VersionSignatures
		enc.Version = string(h.Version)
		enc.VrfValue = h.VrfValue
		enc.AIHash = h.AIHash

		enc.Hash = h.Hash()
		return json.Marshal(&enc)
	} else {
		type Header struct {
			ParentHash common.Hash       `json:"parentHash"       gencodec:"required"`
			UncleHash  common.Hash       `json:"sha3Uncles"       gencodec:"required"`
			Coinbase   common.Address    `json:"miner"            gencodec:"required"`
			Roots      []common.CoinRoot `json:"stateRoot"        gencodec:"required"`
			Sharding   []common.Coinbyte `json:"sharding"        gencodec:"required"`
			Difficulty *hexutil.Big      `json:"difficulty"       gencodec:"required"`
			Number     *hexutil.Big      `json:"number"           gencodec:"required"`
			GasLimit   hexutil.Uint64    `json:"gasLimit"         gencodec:"required"`
			GasUsed    hexutil.Uint64    `json:"gasUsed"          gencodec:"required"`
			Time       *hexutil.Big      `json:"timestamp"        gencodec:"required"`
			Extra      hexutil.Bytes     `json:"extraData"        gencodec:"required"`
			MixDigest  common.Hash       `json:"mixHash"          gencodec:"required"`
			Nonce      BlockNonce        `json:"nonce"            gencodec:"required"`

			Leader            common.Address     `json:"leader"            gencodec:"required"`
			Elect             []common.Elect     `json:"elect"        gencodec:"required"`
			NetTopology       common.NetTopology `json:"nettopology"        gencodec:"required"`
			Signatures        []common.Signature `json:"signatures"        gencodec:"required"`
			VersionSignatures []common.Signature `json:"versionSignatures"              gencodec:"required"`
			Version           string             `json:" version "              gencodec:"required"`
			VrfValue          hexutil.Bytes      `json:"vrfValue"              gencodec:"required"`

			Hash common.Hash `json:"hash"`
		}
		var enc Header
		enc.ParentHash = h.ParentHash
		enc.UncleHash = h.UncleHash
		enc.Coinbase = h.Coinbase
		enc.Roots = h.Roots
		enc.Sharding = h.Sharding
		enc.Difficulty = (*hexutil.Big)(h.Difficulty)
		enc.Number = (*hexutil.Big)(h.Number)
		enc.GasLimit = hexutil.Uint64(h.GasLimit)
		enc.GasUsed = hexutil.Uint64(h.GasUsed)
		enc.Time = (*hexutil.Big)(h.Time)
		enc.Extra = h.Extra
		enc.MixDigest = h.MixDigest
		enc.Nonce = h.Nonce
		enc.Leader = h.Leader
		enc.Elect = h.Elect
		enc.NetTopology = h.NetTopology
		enc.Signatures = h.Signatures
		enc.VersionSignatures = h.VersionSignatures
		enc.Version = string(h.Version)
		enc.VrfValue = h.VrfValue

		enc.Hash = h.Hash()
		return json.Marshal(&enc)
	}
}

func (h *Header) UnmarshalJSON(input []byte) error {
	type Header struct {
		ParentHash *common.Hash       `json:"parentHash"       gencodec:"required"`
		UncleHash  *common.Hash       `json:"sha3Uncles"       gencodec:"required"`
		Coinbase   *common.Address    `json:"miner"            gencodec:"required"`
		Roots      *[]common.CoinRoot `json:"stateRoot"        gencodec:"required"`
		Sharding   *[]common.Coinbyte `json:"sharding"        gencodec:"required"`
		Difficulty *hexutil.Big       `json:"difficulty"       gencodec:"required"`
		Number     *hexutil.Big       `json:"number"           gencodec:"required"`
		GasLimit   *hexutil.Uint64    `json:"gasLimit"         gencodec:"required"`
		GasUsed    *hexutil.Uint64    `json:"gasUsed"          gencodec:"required"`
		Time       *hexutil.Big       `json:"timestamp"        gencodec:"required"`
		Extra      *hexutil.Bytes     `json:"extraData"        gencodec:"required"`
		MixDigest  *common.Hash       `json:"mixHash"          gencodec:"required"`
		Nonce      *BlockNonce        `json:"nonce"            gencodec:"required"`

		Leader            *common.Address     `json:"leader"            gencodec:"required"`
		Elect             *[]common.Elect     `json:"elect"        gencodec:"required"`
		NetTopology       *common.NetTopology `json:"nettopology"        gencodec:"required"`
		Signatures        *[]common.Signature `json:"signatures"        gencodec:"required"`
		VersionSignatures *[]common.Signature `json:"versionSignatures"              gencodec:"required"`
		Version           string              `json:" version "              gencodec:"required"`
		VrfValue          *hexutil.Bytes      `json:"vrfValue"              gencodec:"required"`
		AIHash            *common.Hash        `json:"aiHash"    			gencodec:"required"`
	}
	var dec Header
	if err := json.Unmarshal(input, &dec); err != nil {
		return err
	}
	if dec.ParentHash == nil {
		return errors.New("missing required field 'parentHash' for Header")
	}
	h.ParentHash = *dec.ParentHash

	if dec.UncleHash == nil {
		return errors.New("missing required field 'sha3Uncles' for Header")
	}
	h.UncleHash = *dec.UncleHash

	if dec.Coinbase == nil {
		return errors.New("missing required field 'miner' for Header")
	}
	h.Coinbase = *dec.Coinbase

	if dec.Roots == nil {
		return errors.New("missing required field 'stateRoot' for Header")
	}
	h.Roots = *dec.Roots

	if dec.Sharding == nil {
		return errors.New("missing required field 'transactionsRoot' for Header")
	}
	h.Sharding = *dec.Sharding

	if dec.Difficulty == nil {
		return errors.New("missing required field 'difficulty' for Header")
	}
	h.Difficulty = (*big.Int)(dec.Difficulty)

	if dec.Number == nil {
		return errors.New("missing required field 'number' for Header")
	}
	h.Number = (*big.Int)(dec.Number)

	if dec.GasLimit == nil {
		return errors.New("missing required field 'gasLimit' for Header")
	}
	h.GasLimit = uint64(*dec.GasLimit)
	if dec.GasUsed == nil {
		return errors.New("missing required field 'gasUsed' for Header")
	}
	h.GasUsed = uint64(*dec.GasUsed)
	if dec.Time == nil {
		return errors.New("missing required field 'timestamp' for Header")
	}
	h.Time = (*big.Int)(dec.Time)
	if dec.Extra == nil {
		return errors.New("missing required field 'extraData' for Header")
	}
	h.Extra = *dec.Extra
	if dec.MixDigest == nil {
		return errors.New("missing required field 'mixHash' for Header")
	}
	h.MixDigest = *dec.MixDigest
	if dec.Nonce == nil {
		return errors.New("missing required field 'nonce' for Header")
	}
	h.Nonce = *dec.Nonce

	if dec.Signatures == nil {
		return errors.New("missing required field 'signatures' for Header")
	}
	h.Signatures = *dec.Signatures

	if dec.VersionSignatures == nil {
		return errors.New("missing required field 'version Signatures' for Header")
	}

	h.VersionSignatures = *dec.VersionSignatures
	h.Version = []byte(dec.Version)

	if dec.VrfValue == nil {
		return errors.New("missing required field 'vrfvalue' for Header")
	}
	h.VrfValue = *dec.VrfValue

	if dec.Leader == nil {
		return errors.New("missing required field 'leader' for Header")
	}
	h.Leader = *dec.Leader
	if dec.Elect == nil {
		return errors.New("missing required field 'elect' for Header")
	}
	h.Elect = *dec.Elect

	if dec.NetTopology == nil {
		return errors.New("missing required field 'nettopology' for Header")
	}
	h.NetTopology = *dec.NetTopology

	if manversion.VersionCmp(string(h.Version), manversion.VersionAIMine) >= 0 {
		if dec.AIHash == nil {
			return errors.New("missing required field 'aiHash' for Header")
		}
		h.AIHash = *dec.AIHash
	} else {
		h.AIHash = common.Hash{}
	}

	return nil
}
